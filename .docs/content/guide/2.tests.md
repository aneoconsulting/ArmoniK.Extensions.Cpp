# Run tests

## How to use the ArmoniK C++ SDK

### Build worker and dynamic worker (Linux only)

To utilize ArmoniK with the C++ SDK, you must first build a dynamic worker image. This image is subsequently deployed alongside other ArmoniK components during the deployment phase. The worker runtime offers a suite of business services to ArmoniK clients. It is essential to configure the worker to load a shared library that contains the implementation of the calculation library corresponding to the provided services.

In order to build the dynamic worker image (`armonik-sdk-cpp-dynamicworker`) and the worker test (`libArmoniK.SDK.Worker.Test.so`), please run the following script:

```bash
./tools/build-deploy-end2end.sh
```

This script generates the dynamic worker image that is used to deploy ArmoniK with. The script also generates the shared library used by the worker to perform the ArmoniK call on the desired services. The script will also copy this shared library into the right folder so it can be loaded by the ArmoniK worker.
It is also possible to use the worker image available in the [docker hub ANEO](https://hub.docker.com/r/dockerhubaneo/armonik-sdk-cpp-dynamicworker) and build the shared library separately.

The dynamic worker searches for the shared library to be loaded in the ArmoniK deployment data directory. The `ARMONIK_SHARED_FOLDER` variable specifies the path to this directory, and the `/tools/build-deploy-end2end.sh` script utilizes this variable to copy the built shared library into the folder. If this script is executed without an existing ArmoniK deployment, you will need to set the environment variable manually to the correct directory.

### Deploy ArmoniK

ArmoniK must be configured with a partitition dedicated to the C++ worker image. To do so, you should perform the following actions:

  - Fetch [ArmoniK's](https://github.com/aneoconsulting/ArmoniK) main repository from github if you have not yet done so:
  ```bash
    git clone https://github.com/aneoconsulting/ArmoniK.git
    cd ArmoniK
  ```
- Add the C++ worker image, either by:
  - Replacing the default partition image with the C++ dynamic worker image.
  This is done by modifying the default partition `parameters.tfvars`. For example, using the dynamic worker image provided by the ArmoniK Team:
    ```diff
    default = {
      # number of replicas for each deployment of compute plane
      replicas = 0
      # ArmoniK polling agent
      polling_agent = {...
      }
      # ArmoniK workers
      worker = [
        {
    -     image = "dockerhubaneo/armonik_worker_dll"
    +     image = "dockerhubaneo/armonik-sdk-cpp-dynamicworker"
    +     tag = "0.4.2" 
          limits = {...}
          requests = {...}
        }
      ]
      hpa = {...
      }
    }
    ```

  or
  - Creating a new partition for the C++ worker: You will need to edit the `parameters.tfvars` file and add the new partition with the right image name and tag. For example,
  assuming you built your own worker  `armonik-sdk-cpp-dynamicworker`  and gave it the tag `0.0.0-local`: 
    ```diff
    +cppdynamic = {
    +  # number of replicas for each deployment of compute plane
    +  replicas = 0
    +  # ArmoniK polling agent
    +  polling_agent = {...
    +  }
    +  # ArmoniK workers
    +  worker = [
    +    {
    +      image = "armonik-sdk-cpp-dynamicworker"
    +      tag = "0.0.0-local" 
    +      limits = {...}
    +      requests = {...}
    +    }
    +  ]
    +  hpa = {...
    +  }
    +}
    ```
    _**Note**: This choice requires specifying the partition name in the task options in order to run correctly. If no partition is given in the task options, ArmoniK will use the worker defined in the
    default partition which, almost surely wont be compatible with your Cpp worker._
  
    _**Note**: We support AWS, GCP and a localhost deployments, you should modify the `parameters.tfvars` accordingly. If you cloned
    the ArmoniK repository in your $HOME directory, the file will be located in one of these subdirectories:_
    ```bash
      $HOME/ArmoniK/infrastructure/
      └── quick-deploy
          ├── aws
          ├── gcp
          ├── localhost
          └── onpremise -> localhost
    ```

- Then deploy ArmoniK following the instructions from the [dedicated documentation](https://armonik.readthedocs.io/en/latest/index.html).

### Build the client test and submit jobs

Once the worker is built and ArmoniK is deployed, It is possible to submit jobs by using the client test in the repository. In order to do so, build the client test by launching the cmake at the project root with the flags `BUILD_CLIENT=ON` and `BUILD_END2END=ON`.
After the test build, the environment variable `GrpcClient__Endpoint` must be set to the ArmoniK control plane address in the test environment.
To get the control plane address and port, we can use the following `kubectl` commands:

```bash
export CPIP=$(kubectl get svc control-plane -n armonik -o custom-columns="IP:.spec.clusterIP" --no-headers=true)
export CPPort=$(kubectl get svc control-plane -n armonik -o custom-columns="PORT:.spec.ports[*].port" --no-headers=true)
export GrpcClient__Endpoint=http://$CPIP:$CPPort
```

The worker lib version ```WorkerLib__Version``` must also be specified if the default one (0.1.0) is not used. These values can also be specified in the JSON file when used. Then run in your build environnement:

```bash
cd /app/install/bin```
./ArmoniK.SDK.Client.Test
```

It is also possible to use the test image `armonik_sdk_client_test` generated by the script `/tools/build-deploy-end2end.sh` to run tests. This docker image provides an environment with ArmoniK Client and Client Test built to run tests and submit tasks to ArmoniK.

```bash
docker run --rm -t --network host -e GrpcClient__Endpoint=http://$CPIP:$CPPort -e WorkerLib__Version="$lib_version" armonik_sdk_client_test:"$version"
```

_**Note**: In this subsection we are assuming that you deployed ArmoniK without `tls` validation. If this is not your case, the previous commands should be adapted
to:_
  - Use an `https` ulr instead
  - The `docker run` command should include the options to mount a volume with the certificate, authority and key to perform the ssl validation.
  - Provide the client code the necessary configuration for the ssl validation, this can be done via a JSON file or from environment variables.
